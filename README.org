* Geometry conversion
** B Matrix and s vectors
   See [[pdf:~/Library/McIntosh78.pdf][McIntosh78]] for details on the construction of B matrix
   - in turn it refers to /Molecular Vibrations/, which has been sitting on the floor
     behind me the whole time I was beating my head against the fortran version...

   also see [[https://github.com/psi4/psi3/blob/master/src/bin/intder/README][nate's readme]] from trying to convert it to C++

   I think B does only depend on the simple internals

   B relates the simple internals to the Cartesian coordinates

   This was true, but BS is B converted to symmetry-internal coordinates, and that
   is what is actually used later

   see comments on a_matrix for expression, something like D = BBt and A = BtD-1

   compute A, multiply by the difference between SIC_desired and SIC_current and
   add that step to the Cartesian coordinates

* Force constant conversion
** Fortran code
*** INPFKM - load internal coordinate force constants from file
    - I handle this in =Intder::load=
*** Assemble symmetric B matrix
*** BINVRT - get A matrix, just like geometry conversion
*** MACHX
**** Stretch
     - HIJS1
     - AHX2
**** Bend
     - HIJS2
     - AHX3
**** Torsion
     - HIJS6
     - AHX4
*** MACHY
**** Stretch
     - HIJKS1
     - HSRY2
     - AHY2
**** Bend
     - HIJKS2
     - HSRY3
     - AHY3
**** Torsion
     - HIJKS6
     - HSRY4
     - AHY4
*** LINTR - perform the linear transformations with the matrices from MACHX/Y
*** XF2 - "add X-V(M,N) contributions to third and 4th derivatives"
*** XF3 - "add X-V(M,N,P) contributions to 4th derivatives"
*** YF2 - "add Y-V(M,N) contributions to 4th derivatives"
*** FCOUT - write out the force constants
*** this is where the files are written, then it does the vibrational analysis
**** GFMAT - normal mode analysis in internal coordinates
**** NORMCO - normal mode analysis in cartesian coordinates

* Adding more coordinate types
  So far I have only implemented STRE, BEND, and TORS. The steps for adding more
  are as follows:
  1. Add a new =Siic= variant
  2. Add a new case to =parse_simple_internal=
  3. Follow the compiler to all the places you need to handle the new =Siic=

* Timing
  fairer comparison to DEBUG=true version since that writes something like
  intder.out

  ouch, mine takes longer with 8.8M vs 14.9M lines printed. lines weren't the
  whole story though. my lines are wider so file size is 1.4 GB vs 800 MB for
  mine and the old version, respectively. that explains mine taking longer

  | Molecule  | Old       | New+Debug | New       |
  |-----------+-----------+-----------+-----------|
  | C7H2 Orig | 1m18.593s | 2m2.780s  | 0m26.215s |
  | C7H2 prof |           | 1m51.760s | 0m16.808s |

* TODO make sure NSIC = 0 works
  should make it possible to use just simple internals for Cs molecules, for
  example. this might work if I just loop over symmetry_internals everywhere
  right now, but I'm not sure

* References
  - D. F. McIntosh, K. H. Michaelian, and M. R. Peterson. Can. J. Chem. Vol. 56,
    1978
  - E. B. Wilson, Jr., J. C. Decius, and P. C. Cross. Molecular
    Vibrations, 1955.
  - W. D. Allen and A. G. Csaszar. J. Chem. Phys. 98, 1993.
  - A. L. L. East, W. D. Allen, and S. J. Klippenstein. J. Chem. Phys. 102, 1995

* Potential improvements
  - use a single vector for Tensor3 and Tensor4 with the indexing formulas. this
    should make FILL{3,4}{A,B} unneccessary if they just fill across the
    diagonals because the indexing formulas already take care of the symmetry

* Extra code
** fcout for f3 I think
   #+begin_src rust
     // TODO follow F3 out of LINTR before it gets to FCOUT - some other
     // transformations are happening, probably bringing back the pieces
     // written to disk

     const CF3: f64 = ANGBOHR * ANGBOHR * ANGBOHR / HART;
     let mut f3_units = Tensor3::zeros(nsx, nsx, nsx);
     let mut _c = 0;
     for p in 0..nsx {
	 for n in 0..nsx {
	     for m in 0..nsx {
		 // if c > 0 && c % 3 == 0 {
		 //     println!();
		 // }
		 // print!("{:12.6}", CF3 * f3[(m, n, p)]);
		 // c += 1;
		 f3_units[(m, n, p)] = CF3 * f3[(m, n, p)];
	     }
	 }
     }
     f3_units.print();
     dbg!(c);
   #+end_src
